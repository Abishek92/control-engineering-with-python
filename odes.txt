% Ordinary Differential Equations
% Sébastien Boisgérault, Mines ParisTech

Preamble
--------------------------------------------------------------------------------

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    from numpy import *
    from numpy.linalg import *
    from matplotlib.pyplot import *

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: notebook :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    from numpy import *
    import matplotlib; matplotlib.use("nbAgg")
    from matplotlib.pyplot import *
    %matplotlib notebook 

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    # Python 3.x Standard Library
    import gc
    import os

    # Third-Party Packages
    import numpy as np; np.seterr(all="ignore")
    import numpy.linalg as la
    import scipy.misc
    import matplotlib as mpl; mpl.use("Agg")
    import matplotlib.pyplot as pp
    import matplotlib.axes as ax
    import matplotlib.patches as pa


    #
    # Matplotlib Configuration & Helper Functions
    # --------------------------------------------------------------------------
    
    # TODO: also reconsider line width and markersize stuff "for the web
    #       settings".
    fontsize = 35

    rc = {
        "text.usetex": True,
        "pgf.preamble": [r"\usepackage{amsmath,amsfonts,amssymb}"], 
        #"font.family": "serif",
        "font.serif": [],
        #"font.sans-serif": [],
        "legend.fontsize": fontsize, 
        "axes.titlesize":  fontsize,
        "axes.labelsize":  fontsize,
        "xtick.labelsize": fontsize,
        "ytick.labelsize": fontsize,
        #"savefig.dpi": 300,
        #"figure.dpi": 300,
    }
    mpl.rcParams.update(rc)

    # Web target: 160 / 9 inches (that's ~45 cm, this is huge) at 90 dpi 
    # (the "standard" dpi for Web computations) gives 1600 px.
    width_in = 160 / 9 

    def save(name):
        cwd = os.getcwd()
        root = os.path.dirname(os.path.realpath(__file__))
        os.chdir(root)
        pp.savefig(name + ".svg")
        os.chdir(cwd)

    def set_ratio(ratio=1.0, bottom=0.1, top=0.1, left=0.1, right=0.1):
        height_in = (1.0 - left - right)/(1.0 - bottom - top) * width_in / ratio
        pp.gcf().set_size_inches((width_in, height_in))
        pp.gcf().subplots_adjust(bottom=bottom, top=1.0-top, left=left, right=1.0-right)

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


Introduction to ODEs
================================================================================

--------------------------------------------------------------------------------

First pass, basic concepts, some visualisation tools

--------------------------------------------------------------------------------

Initial Value Problem 
--------------------------------------------------------------------------------

Let $n \in \mathbb{N}^*$ and $f:\mathbb{R}^n \to \mathbb{R}^n$. 

The **initial-value problem** (IVP) with **right-hand side** 
(or **vector field**) $f$ refers to:

  $$
  \dot{x} = f(x) \; \mbox{ and } \;  x(t_0) = x_0 
  $$

--------------------------------------------------------------------------------

The **initial condition** $(t_0, x_0)$ is made of 

  - the **initial time** $t_0 \in \mathbb{R}$ and 

  - the **initial value** or **initial state** $x_0 \in \mathbb{R}^n$.
 
The set $\mathbb{R}^n$ is the **state space**.


Higher-Order ODEs
--------------------------------------------------------------------------------

Scalar differential equations structured as

  $$
  x^{(n)}(t) = f(x, \dot{x}, \ddot{x}, \dots, x^{(n-1)})
  $$

can be converted to the standard form with the state
 
  $$
  y = (x, \dot{x}, \ddot{x}, \dots, x^{(n-1)}) \in \mathbb{R^n}
  $$

  $$
  \begin{array}{lll}
  \dot{y}_1 &=& y_2 \\
  \dot{y}_2 &=& y_3 \\
  \vdots &\vdots& \vdots \\
  \dot{y}_n = f(y_1, y_2, \dots, y_{n-1})
  \end{array}
  $$


--------------------------------------------------------------------------------

### Example -- Pendulum

**TODO:** drawing, explain parameters, animation later maybe

Consider

  $$
  m \ell^2 \ddot{\theta} + b \dot{\theta} + m g \ell \sin \theta = 0
  $$

Introduce the rotational frequency $\omega = \dot{\theta}$.  
The equation above is equivalent to:

  $$
  \begin{array}{lll}
  \dot{\theta} &=& \omega \\
  \dot{\omega} &=& - b \omega -(g /\ell) \sin \theta  
  \end{array}
  $$

--------------------------------------------------------------------------------

**NOTA:** too early, the `fun` signature is not known yet.

    def pendulum(m=1.0, l=1.0, k=1.0, g=9.81):
        def fun(t, y):
            theta, d_theta = y
            J = m * l * l
            d2_theta = - b / J * d_theta - g / l * sin(theta)
            return [d_theta, d2_theta]
        return fun
            


Solution of the IVP 
--------------------------------------------------------------------------------

A differentiable function 

  $$
  x: t \in  \left[t_0, +\infty \right[ \mapsto x(t) \in \mathbb{R}^n,
  $$ 

such that:

  - for every $t \geq t_0$, $\dot{x}(t) = f(x(t))$. 

  - $x(t_0) = x_0$

The **state of the system** at time $t$ is $x(t)$.

Numerical Solution 
--------------------------------------------------------------------------------

Given a finite **time span** $[t_0, t_f]$ and a small enough **time step**
$\Delta t > 0$, we can use the approximation:

  $$
  \begin{split}
  x(t + \Delta t) 
    & \simeq x(t) + \Delta t \times \dot{x}(t) \\
    & = x(t) + \Delta t \times f(x(t)) \\
  \end{split}
  $$

to compute a sequence of states $x_k \in \mathbb{R}^n$ such that:

  $$
  x(t = k \Delta t) \simeq x_k.
  $$


Euler Scheme
--------------------------------------------------------------------------------

(Fixed-step & explicit version) 

    def basic_solve_ivp(f, t0, x0, dt, t_f):
        ts, xs = [t0], [x0]
        while ts[-1] <= t_f:
            t, x = ts[-1], xs[-1]
            t_next, x_next = t + dt, x + dt * f(x)
            ts.append(t_next); xs.append(x_next)
        return (array(ts), array(xs).T)




Visualization
--------------------------------------------------------------------------------

**TODO:** 2D vs 3D, paths vs trajectories in state-space, etc.
quivers, stream plots, etc.

**TODO:** animations ? (simple, in the phase space, with trailing stuff?)


Example
--------------------------------------------------------------------------------

  $$
  \left|
  \begin{split}
  \dot{x} &= -y \\
  \dot{y} &= +x
  \end{split}
  \right.,
  \; \mbox{ with } \;
  \left|
  \begin{array}{l}
  x(0) = 1\\
  y(0) = 0
  \end{array}
  \right.
  $$


--------------------------------------------------------------------------------



[Quiver](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.streamplot.html) Helper
--------------------------------------------------------------------------------

    def Q(f, xs, ys):

        #print("f", f)

        X, Y = meshgrid(xs, ys)
        fx = vectorize(lambda x, y: f([x, y])[0])
        fy = vectorize(lambda x, y: f([x, y])[1])
        return X, Y, fx(X, Y), fy(X, Y)

--------------------------------------------------------------------------------

    def f(xy):
        return array([-xy[1], xy[0]])
    figure()
    x = arange(0.0, 2.0, 0.1)
    y = arange(-1.0, 2.0, 0.1)
    quiver(*Q(f, x, y)) 

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    save("images/test_Q")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Result
--------------------------------------------------------------------------------

![](images/test_Q.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



State Space: Vector Field
--------------------------------------------------------------------------------

    def f(xy):
        return array([-xy[1], xy[0]])

    figure()
    xs = arange(-1.0, 1.0, 0.1)
    ys = arange(-1.0, 1.0, 0.1)
    quiver(*Q(f, xs, ys))
    grid(); axis("equal")

--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    tight_layout()
    save("images/vector-field")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

State Space: Vector Field
--------------------------------------------------------------------------------

![](images/vector-field.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

--------------------------------------------------------------------------------

    t0, x0 = 0.0, [-1.0, 0.0]
    dt, tf = 0.01, 12.0
    ts, xs = basic_solve_ivp(f, t0, x0, dt, tf)

--------------------------------------------------------------------------------

**TODO:** simplify, get rid of subplots at this stage

    figure()
    _, (ax1, ax2) = subplots(2, 1)
    ax1.plot(ts, xs[0], "k")
    ax2.plot(ts, xs[1], "k")
    ax1.set_title("$x(t)$")
    ax2.set_title("$y(t)$")


::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    #pp.gcf().subplots_adjust(bottom=0.25, top=0.75, left=0.1, right=0.9, 
    #                         hspace=0.75)
    tight_layout()
    save("images/rotation")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Result
--------------------------------------------------------------------------------

![](images/rotation.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

--------------------------------------------------------------------------------

**TODO:** arrow helper (use std & option markerwidth for integration)

--------------------------------------------------------------------------------

    figure()
    quiver(*Q(f, arange(-1.5, 1.5, 0.1), arange(-1.5, 1.5, 0.1)), color="grey")
    plot(xs[0], xs[1], "k")
    plot(x0[0], x0[1], "ko")
    dx = xs[0][-1] - xs[0][-2]
    dy = xs[1][-1] - xs[1][-2]
    arrow(xs[0][-1], xs[1][-1], dx, dy, width=0.02, color="k")
    grid()
    axis("equal")

Note: `arrow` does not rescale like markers -- such as the initial point --
      do :(

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    tight_layout()
    save("images/rotation2")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Result
--------------------------------------------------------------------------------

![](images/rotation2.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::




Numerical Solutions
================================================================================



--------------------------------------------------------------------------------

There are many issues that our basic solver doesn't address:

  - non-autonomous systems

  - error control,

  - dense outputs,

  - and more ...

--------------------------------------------------------------------------------

Instead, use:

    from scipy.integrate import solve_ivp

Documentation: [`solve_ivp`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html) (Scipy)


Example
--------------------------------------------------------------------------------

Compute the solution $x(t)$ for $t\in[0,2\pi]$ of the IVP:

  $$
  \left|
  \begin{split}
  \dot{x_1} &= -x_2 \\
  \dot{x_2} &= +x_1
  \end{split}
  \right.
  \; \mbox{ with } \;
  \left|
  \begin{array}{l}
  x_1(0) = 1\\
  x_2(0) = 0
  \end{array}
  \right.
  $$


Basic Interface
--------------------------------------------------------------------------------

    def fun(t, y):
        x1, x2 = y
        return [-x2, x1]
    t_span = [0.0, 2*pi]
    y0 = [1.0, 0.0]
    result = solve_ivp(fun=fun, t_span=t_span, y0=y0)

Non-Autonomous Systems
--------------------------------------------------------------------------------

<i class="fa fa-warning"></i> Since the solver is applicable to
non-autonomous systems 

  $$
  \dot{y} = f(t, y)
  $$ 
the `t` argument in the definition of `fun` is mandatory, 
even if the returned doesn't depend on it (autonomous system).


--------------------------------------------------------------------------------

    figure()
    t = linspace(0, 2*pi, 1000)
    plot(t, cos(t), "k--")
    plot(t, sin(t), "k--")
    bold = {"lw": 2.0, "ms": 10.0}
    plot(result["t"], result["y"][0], ".-", label="$x_1(t)$", **bold)
    plot(result["t"], result["y"][1], ".-", label="$x_2(t)$", **bold)
    xlabel("$t$"); grid(); legend()

--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    tight_layout()
    save("images/solve_ivp_1")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


![](images/solve_ivp_1.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


Variable Step Size
--------------------------------------------------------------------------------

The step size is:

  - variable: $t_{n+1} - t_n$ may not be constant, 

  - automatically selected by the algorithm,

The solver shall meet the user specification,
but should select the largest step size to do so 
to minimize the number of computations.

Optionally, you can specify a `max_step` (default: $+\infty$).


Error Control
--------------------------------------------------------------------------------

We generally want to control the error $e(t)$:   
the difference between the numerical solution and the exact one.

  - `atol` is the **absolute tolerance** (default: $10^{-6}$),

  - `rtol` is the **relative tolerance** (default: $10^{-3}$).

The solver ensures (approximately) that:

  $$
  |e(t)| \leq \mathrm{atol} + \mathrm{rtol} \times |x(t)|
  $$

--------------------------------------------------------------------------------

    options = {
        # at least 20 data points
        "max_step": 2*pi / 20, 
        # standard absolute tolerance
        "atol"    : 1e-6,        
        # very large relative tolerance
        "rtol"    : 1e9 
    }
    result = solve_ivp(
        fun=fun, t_span=t_span, y0=y0, 
        **options
    )

--------------------------------------------------------------------------------

    figure()
    t = linspace(0, 2*pi, 20)
    plot(t, cos(t), "k--")
    plot(t, sin(t), "k--")
    bold = {"lw": 2.0, "ms": 10.0}
    plot(result["t"], result["y"][0], ".-", label="$x_1(t)$", **bold)
    plot(result["t"], result["y"][1], ".-", label="$x_2(t)$", **bold)
    xlabel("$t$"); grid(); legend()

--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    tight_layout()
    save("images/solve_ivp_2")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


![](images/solve_ivp_2.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Dense Output
--------------------------------------------------------------------------------

Using a small `max_step` is usually the wrong way to "get more data points" 
since this will trigger many (potentially expensive) evaluations of `fun`.

Instead, use dense outputs: the solver may return  
the discrete data `result["t"]` and `result["y"]` 
**and** an approximate 
solution `result["sol"]` **as a function of `t`**
with little extra computations.

--------------------------------------------------------------------------------

    options = {
        "dense_output": True
    }
    result = solve_ivp(
        fun=fun, t_span=t_span, y0=y0, 
        **options
    )

--------------------------------------------------------------------------------

    figure()
    t = linspace(0, 2*pi, 1000)
    plot(t, cos(t), "k--")
    plot(t, sin(t), "k--")
    bold = {"lw": 2.0, "ms": 10.0}
    y = result["sol"]
    plot(t, y(t)[0], "-", label="$x_1(t)$", **bold)
    plot(t, y(t)[1], "-", label="$x_2(t)$", **bold)
    plot(result["t"], result["y"][0], ".", color="C0", **bold)
    plot(result["t"], result["y"][1], ".", color="C1", **bold)
    xlabel("$t$"); grid(); legend()

--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    tight_layout()
    save("images/solve_ivp_3")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


![](images/solve_ivp_3.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


<!--

--------------------------------------------------------------------------------

    def explicit_euler_step(fun, t, y, step):
        return y + step * fun(t, y)

Example
--------------------------------------------------------------------------------


----

    class ODEScheme:
        def __init__(self, fun, t0, y0, max_step, tf):
            self.fun = fun
            self.t = t0
            self.y = y0
            self.max_step = max_step
            self.tf = tf

----

    class ExplicitEuler(ODEScheme):
        def step(self):
            t_next = min(self.tf, \
                         self.t + self.max_step)
            step = t_next - self.t
            y_next = explicit_euler_step(self.fun, \
                                         self.t,   \
                                         self.y,   \
                                         step      )
            self.t = t_next
            self.y = y_next


Interpolation
--------------------------------------------------------------------------------

    from scipy.interpolate import interp1d
    def interpolate(ti, yi):
        def function(t):
            options = {"axis": 0, \
                       "fill_value": "extrapolate"}
            return interp1d(ti, yi, **options)(t).T
        return function

Example
--------------------------------------------------------------------------------

    ti, yi = array([0, 1, 2]), array([1, 2, 1])
    f = interpolate(ti, yi)
    t = linspace(-1, 3, 100)
    y = f(t)
    figure()
    plot(ti, yi, "ko")
    plot(t, y, "k--")

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    save("images/interpolation")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Result
--------------------------------------------------------------------------------

![](images/interpolation.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

-----

    def solve_ivp(fun, t_span, y0, \
                  max_step=1e-5, \
                  dense_output=False, \
                  **options):
        t0, tf = t_span
        scheme = ExplicitEuler(fun, t0, y0, max_step, tf)

        result = {}
        t, y = [t0], [y0]
        try:
            while t[-1] < tf:
                scheme.step()
                t.append(scheme.t)
                y.append(scheme.y)
            result["success"] = True
        except: # too wide. What can happen here ? nan stuff ?
            result["success"] = False
        result["t"] = t = array(t)
        result["y"] = y = array(y)
        if dense_output:
            result["sol"] = interpolate(t, y)
        else:
            result["sol"] = None
        return result  

-----

    def fun(t, y):
        return y

    t0, tf, y0 = 0.0, 5.0, array([1.0])
    result = solve_ivp(fun, (t0, tf), y0, \
                       max_step=0.25, \
                       dense_output=True)

------

    td, yd = result["t"], result["y"]
    t = linspace(t0, tf, 1000)
    y = result["sol"](t)
    figure()
    plot(t, exp(t), "k")
    plot(t, y.T, "k--")
    plot(td, yd, "k+")


::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    save("images/exp")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Results
--------------------------------------------------------------------------------

![](images/exp.svg)

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


-->


Well-Posedness
================================================================================

--------------------------------------------------------------------------------

So far, we have only dealt with **global** solutions $x(t)$ of IVPs,
defined for any $t \geq t_0$.


This concept is sometimes too stringent.

Consider for example:

  $$
  \dot{x} = x^2 \; \mbox{ and } \; x(0)=1
  $$

-----

    def fun(t, y):
        return y * y
    t0, tf, y0 = 0.0, 3.0, array([1.0])
    result = solve_ivp(fun, t_span=[t0, tf], y0=y0)
    figure()
    plot(result["t"], result["y"][0], "k")
    xlim(t0, tf); xlabel("$t$"); ylabel("$x(t)$")


::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    tight_layout()
    save("images/finite-time-blowup")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

--------------------------------------------------------------------------------

![](images/finite-time-blowup.svg)

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

--------------------------------------------------------------------------------

Ouch.

There is actually no **global** solution. 

However there is **local** solution $x(t)$, 
defined for $t \in \left[t_0, \tau\right[$
for some $\tau > t_0$.

--------------------------------------------------------------------------------

Indeed, let $t_f=1$; the function

  $$
  x(t) = \frac{1}{1 - t}, t \in \left[0, 1\right[ 
  $$

satisfies

  - for every $t \in \left[t_0, t_f\right[$, $\dot{x}(t) = f(x(t))$,

  - $x(t_0) = x_0$.

--------------------------------------------------------------------------------

    tf = 1.0

    result = solve_ivp(fun, t_span=[t0, tf], y0=y0)
    figure()
    plot(result["t"], result["y"][0], "k")
    ylim(0.0, 10.0); grid(); xlabel("$t$"); ylabel("$x(t)$")

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    tight_layout()
    save("images/finite-time-blowup-2")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

--------------------------------------------------------------------------------

![](images/finite-time-blowup-2.svg)

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

--------------------------------------------------------------------------------

This local solution is also **maximal**:

You cannot extend this solution beyond $\tau=1.0$.


--------------------------------------------------------------------------------

**TODO:** Exo sim numerique avec sol bornée sur range initial. 
Tirer ccl que sol pas maximale.

Ex avec genre $\dot{x} = x^3$ ?






Local Existence
--------------------------------------------------------------------------------

If $f$ is continuous, 

  - There is a (at least one) local solution to the IVP

      $$
      \dot{x} = f(x) \; \mbox{ and } x(t_0) = x_0 
      $$

  - Any local solution on some $\left[t_0, \tau \right[$ 
    can be extended to a (at least one) maximal one 
    on some $\left[t_0, t_{\infty}\right[$.

  - A maximal solution is global iff $t_{\infty} = +\infty$.


Maximal Solutions
--------------------------------------------------------------------------------

A local solution on $\left[t_0, \tau \right[$ is maximal when 

  $$
  \lim_{t \uparrow \tau} \|x(t)\| = +\infty.
  $$

### Corollary

If any *potential* local solution $x(t)$ defined on 
$\left[t_0, \tau\right[$ is bounded on this interval,
then such a solution exists.  
It is not maximal (it can be extended).


--------------------------------------------------------------------------------

### <i class="fa fa-question-circle-o"></i> -- Existence / Sigmoid

Consider

  $$
  \dot{x} = \frac{1}{1 + e^{-x}} \mbox{ with } x(0) = x_0 \in \mathbb{R}
  $$


  - [</i><i class="fa fa-superscript"></i>] 
    Show that there is a (at least one) maximal solution.

  - [<i class="fa fa-superscript"></i>] 
    Show that any such solution is global.

--------------------------------------------------------------------------------

### <i class="fa fa-question-circle-o"></i> -- Existence / Linear Systems

Let $A \in \mathbb{R}^{n \times n}$ and $x_0 \in \mathbb{R}^n$. Consider
  $$
  \dot{x} = A x \; \mbox{ and } \; x(0) = x_0
  $$

<i class="fa fa-bullseye"></i> **Aim.** Show that any maximal solution is global.

**TODO:** there exist too ...

--------------------------------------------------------------------------------

  - [</i><i class="fa fa-superscript"></i>] 
    Show that $y(t) = \|x(t)\|^2$ is differentiable and 
    satisfies $y(t) \geq 0$ and 
    $\dot{y}(t) \leq \alpha y(t)$ for some $\alpha \geq 0$.

  - [</i><i class="fa fa-superscript"></i>]
    Compute the derivative of $y(t) e^{-\alpha t}$ and conclude that
    $0 \leq y(t) \leq y(0) e^{\alpha t}$.

  - [</i><i class="fa fa-superscript"></i>]
    Prove that any maximal solution $x(t)$ of the initial IVP is global.


Example - Discontinuous Vector Field
--------------------------------------------------------------------------------

Consider the scalar IVP with initial value $x(0) = 0$ and right-hand side
  $$
  f(x) = 
  \left|
  \begin{array}{rl}
  +1 & \mbox{if } \; x < 0 \\
  -1 & \mbox{if } \; x \geq 0.
  \end{array}
  \right.
  $$
Assume that $x: I \to \mathbb{R}$ is a local solution of this IVP
and left $\varepsilon > 0$ be such that $[0,\varepsilon] \subset I$. 
Since $\dot{x}(0) = +1 > 0$,
for some small enough $0 < \tau < \epsilon$ and any $t \in [0, \tau]$,
we have $x(t) > 0$. 
Consequently, $\dot{x}(t) = -1$ and thus by integration
  $$
  x(\tau) =  x(0) + \int_0^{\tau} \dot{x}(t) \, dt = 0 - t < 0,
  $$
which is a contradiction. Thus there is no local solution to this IVP.

Uniqueness
--------------------------------------------------------------------------------

If $\partial f/\partial x$ exists and is continuous,  
the maximal solution is unique.

--------------------------------------------------------------------------------

### Non-Uniqueness -- <i class="fa fa-superscript"></i> 

Explain why the IVP $\dot{x} = \sqrt{x}$, $x(0) = 0$ 
may have several maximal solutions. 
Then, investigate if multiple solutions 
actually exist.

**Hint.** Consider
  $$
  x(t) = 
  \left| 
  \begin{array}{ll}
  0 & \mbox{if} \; t \leq \tau, \\
  1/4 \times (t-\tau)^2 & \mbox{if} \; t > \tau.
  \end{array}
  \right.
  $$


Continuity w.r.t. the Initial State
--------------------------------------------------------------------------------

Assume that $\partial f / \partial x$ exists and is continuous.  

If $x(t, x_0)$ is defined on $[t_0, t_f[$ and $t\in \left[t_0, t_f\right[$:

 $$
 x(t, y) \to x(t, x_0) \; \mbox{when} \; y \to x_0
 $$

For any $\tau \in \left[t_0, t_f\right[$,
this convergence t is uniform w.r.t. $t \in [t_0, \tau]$ 


--------------------------------------------------------------------------------

:::: hidden ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    alpha = 2 / 3
    beta = 4 / 3
    delta = gamma = 1.0
    def f(t, y):
        x, y = y 
        u = alpha * x - beta * x * y
        v = delta * x * y - gamma * y
        return array([u, v])

    tf = 3.0
    result = solve_ivp(f, t_span=[0.0, tf], y0=[1.5, 1.5], max_step=0.01)
    x = result["y"][0]
    y = result["y"][1]
    figure(); ax = gca()
    streamplot(*Q(lambda y: f(0,y), linspace(0.0, 2.0, 1000), linspace(0.0, 2.0, 1000)), color="grey")
    for xy in zip(x, y):
        x_, y_ = xy
        ax.add_artist(Circle((x_, y_), 0.2, color="C1"))
    ax.add_artist(Circle((x[0], y[0]), 0.1, color="C2"))

    plot(x, y, "k")

    result = solve_ivp(f, t_span=[0.0, tf], y0=[1.5, 1.575], max_step=0.01)
    x = result["y"][0]
    y = result["y"][1]
    plot(x, y, "k--")

    axis([0,2,0,2]); axis("square")


    save("images/continuity")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

![](images/continuity.svg)  

--------------------------------------------------------------------------------

**TODO:** Explain that it says nothing about the long-term behavior of the
error, or the quantitative speed at which two solution diverge.

--------------------------------------------------------------------------------

Well-Posedness
--------------------------------------------------------------------------------

Well-Posedness = Existence + Uniqueness + Continuity

Necessary condition for the soundness of numerical scheme.


--------------------------------------------------------------------------------

### <i class="fa fa-question-circle-o"></i> -- Continuity / Initial Value

Let $h \geq 0$ and $x^h(t)$ be the solution of $\dot{x} = x$ 
and $x^h(0) = 1+ h$.

  - [<i class="fa fa-superscript"></i>]. Let $\epsilon > 0$; 
    find the smallest  $\delta > 0$ such that 
    $|h| < \delta$ ensures that
    $$\mbox{for any $t \in [t_0, t_f]$}, |x^{h}(t) - x^0(t)| < \epsilon$$



--------------------------------------------------------------------------------

  - [<i class="fa fa-superscript"></i>]. What is the behavior of
    $\delta$ when $t_f$ goes to infinity?


--------------------------------------------------------------------------------

### <i class="fa fa-question-circle-o"></i> -- Continuity / Initial Value

Consider $\dot{x} = \sqrt{|x|}$, $x(0)=x_0$.

  - [<i class="fa fa-laptop"></i>]
    Solve numerically this IVP for $t \in [0,1]$ and $x_0 = 0$. 
    Then, solve it again for $x_0 = 0.1$, $x_0=0.01$, etc.

  - [<i class="fa fa-flask"></i>]
    Does the solution seem to be continuous with respect to the initial value?

  - [<i class="fa fa-cogs"></i>] 
    Explain this experimental result.




ODEs: Extra Variants
================================================================================

--------------------------------------------------------------------------------

We consider the initial-value problem (IVP)
  $$
  \dot{x} = f(t, x), \; x(t_0) = x_0
  $$
where $f: I \times U \to \mathbb{R}^n$, $I$ is an open interval of
$\mathbb{R}$, $t_0 \in I$, $U$ is an open subset of $\mathbb{R}^n$
and $x_0 \in U$.

--------------------------------------------------------------------------------

#### Initial Time {.note}

We often let the initial time $t_0$ is unspecified. 
In this case we will assume that it is zero.
It makes sense since we can deduce the set of solutions in the general case
of an initial condition $(x_0, t_0)$ from the set of solution with initial
condition $(x_0, 0)$: the function $y:\left[t_0, +\infty\right[$ is a solution
of the former if and only if 
  $$
  x: t \in \left[0, +\infty \right[ \to x(t) = y(t-t_0)
  $$
is a solution of the latter.

-----

#### Future and Past {.note}

Some authors require a global solution to be defined for any time $t$
in the future of the initial time $t_0$ but also for any value in its past,
and thus for any $t \in \left]-\infty, +\infty \right[$. We don't abide to
this definition by default since it makes the terminology of "initial time" 
a bit confusing. 
However, if the need arises, we may characterize such a solution
$x: t \in \left]-\infty, +\infty \right[ \to \mathbb{R}^n$ by two classic 
global solutions: $x^+(t)$, defined for $t \geq 0$ 
as a solution of the IVP
  $$
  x^+(0) = x_0 \; \mbox{ and } \; \dot{x}^+ = f(x^+).
  $$
and the solution $x^-(t)$, also defined for $t \geq 0$ 
but a solution of the IVP with a reverse right-hand side
  $$
  x^-(0) = x_0 \; \mbox{ and } \; \dot{x}^- = - f(x^-).
  $$
The complete solution is then given by
  $$
  x(t) 
  = 
  \left|
  \begin{array}{ll}
  x^+(t) & \mbox{if } \; t \geq 0 \\
  x^-(-t) & \mbox{if } \; t < 0. \\
  \end{array}
  \right.
  $$

### Complex-Valued Differential Equations {.note}

**TODO.**



### Irregular Right-Hand Sides

"Absolutely continuous" solutions:

  $$
  f(t) = \int_{t_0}^t g(s) \, ds
  $$

  $$
  x(t) = x_0 + \int_{t_0}^t f(s, x(s))\, ds
  $$

Discont wrt $x$ and Filipov solutions.

--------------------------------------------------------------------------------


General "what can go wrong approach" for the existence and uniqueness of ODEs.

Start with autonomous equations.

Go for simple "really-differential-equations" with continuity of $f$ and
$\partial f / \partial x$ stuff.

Local existence and local uniqueness can be splitted.

Deal with time-reversal somehow ?

Consequence of uniqueness (combined with time-reversal): ex: show that you 
cannot reach a boundary where the rhs is zero in finite time.

Complete well-posedness to account for continuity wrt initial condition ?

Show that local existence and uniqueness implies that NON-existence means
getting out of every compact set (under the form of: either going to infinity
or approaching the boundary arbitrarily close.)

Application: linear equation $\dot{x} = A x$. Show that the derivative
of $y = |x|^2$ is dominated by $2\|A\|y$ and thus with $a=\|A\|$
that $|y|(t) \leq e^{at} |y|(0)$ (proof ?) which forbids $x$ 
to go to $+\infty$.

Same kind of stuff via invariant in the prey-predator model ? 
Yes. The model $\dot{x} = \alpha x - \beta x y$ and 
$\dot{y} = \delta xy - \gamma y$ has the invariant
$\delta x - \gamma \ln x +\beta y - \alpha \ln y$,
which is good enough to prove global existence.

Flow notation.

Trick to include the time in this framework and how to deal with
$n$-th order equations.


"Fix" this later to account for discontinuous stuff wrt $t$,
if necessary.



Prey-Predator Models
--------------------------------------------------------------------------------

    figure()

    Y, X = np.mgrid[0.0:2.0:200j, 0.0:4.0:200j]

    alpha = 2 / 3
    beta = 4 / 3
    delta = gamma = 1.0
    U = alpha * X - beta * X * Y
    V = delta * X * Y - gamma * Y

    axes().set_aspect(1.0)
    axes().axis([0.0, 4.0, 0.0, 2.0])    

    streamplot(X, Y, U, V, color="k")


## TODO: 

  - split notebook and slides settings. Mmm how deal with styles ?
    Have "standard options" for notebook and slides and use them
    beforehand in some option stuff ? Or duplicate the plot code,
    this is not such a big deal.


::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    height_in = width_in / (16 / 9)
    pp.gcf().set_size_inches((width_in, height_in)) # height_in ignored ?
    # weight_in does not match ? dpi issue ? Prob. cause changing width_in 
    # does have an influence.

    # This is the bbox_in: tight options that is messing with us ...
    # (width and height). Investigate what that stuff is doing.

    save("images/prey-predator")     # TODO: use "savefig.dpi" param instead in rc.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

----

![](images/prey-predator.svg)


Asymptotic (Long-Term) Behavior
================================================================================



Lorenz System
--------------------------------------------------------------------------------

  $$
  \begin{array}{lll}
  \dot{x} &=& \sigma (y - x) \\
  \dot{y} &=& x (\rho - z) \\
  \dot{z} &=& xy - \beta z 
  \end{array}
  $$

--------------------------------------------------------------------------------

[![](images/static/lorenz-attractor.png)](https://portsmouth.github.io/fibre/?settings=eyJSIjp7InJheUJhdGNoIjoxMjgsIm1heFRpbWVTdGVwcyI6MjI5LCJtYXhJdGVyYXRpb25zIjoxMDAsImludGVncmF0aW9uVGltZSI6MiwiaW50ZWdyYXRlRm9yd2FyZCI6dHJ1ZSwiZ3JpZFNwYWNlIjowLjAzMzA4MjA1NjczMzUyMTgwNCwidHViZVdpZHRoIjowLjAxMzIzMjgyMjY5MzQwODcyMywidHViZVNwcmVhZCI6ZmFsc2UsInJlY29yZF9yZWFsdGltZSI6dHJ1ZSwieG1pbiI6MTguMTI3NTIxNDk3MTg5NjI2LCJ4bWF4IjoyNi43NDEyMjM2ODMyMjY3NzgsInltaW4iOi0xNS4xMDMyMzE2NzQyNjQ5NDUsInltYXgiOi04LjczODI1MzU0Njc5NDE0Mywiem1pbiI6MTkuMjU3MzA2NjExNDgwNjYsInptYXgiOjIxLjU4ODgyMDMyODM4NTQ2MywiY2xpcFRvQm91bmRzIjpmYWxzZSwic2hvd0JvdW5kcyI6dHJ1ZSwiZXhwb3N1cmUiOi0wLjc1MzM5MjIwMzMxNjgyMSwiZ2FtbWEiOjAuOTkyNDYxNzAyMDA1NjU2NSwiY29udHJhc3QiOjEuMTIyMzM0Njk3MzkzOTI2Mywic2F0dXJhdGlvbiI6MS4zODY5OTExNjk1MDI0NzcsInN1YnRyYWN0aXZlQ29sb3IiOmZhbHNlLCJiZ0NvbG9yIjpbMCwwLDBdLCJoYWlyU2hhZGVyIjpmYWxzZSwic3BlY1NoaW5lIjoyMS45NzI4NjIzNzM0NjU0MzIsInNwZWNDb2xvciI6WzAuOTAxOTUzMjc1MDg4MDg4MSwwLjg5MzEwOTkxODYyMzQ5MjEsMC44OTMxMDk5MTg2MjM0OTIxXSwibGlnaHQxX2NvbG9yIjpbMSwwLjksMC44XSwibGlnaHQyX2NvbG9yIjpbMC44LDAuOSwxXSwibGlnaHQxX2RpciI6WzAuNTc3MzUwMjY5MTg5NjI1OCwwLjU3NzM1MDI2OTE4OTYyNTgsMC41NzczNTAyNjkxODk2MjU4XSwibGlnaHQyX2RpciI6Wy0wLjU3NzM1MDI2OTE4OTYyNTgsLTAuNTc3MzUwMjY5MTg5NjI1OCwtMC41NzczNTAyNjkxODk2MjU4XSwiZGVwdGhUZXN0Ijp0cnVlLCJkYXNoX3NwYWNpbmciOjAuNTQwMzQwMjU5OTgwODU3NCwiZGFzaF9zcGVlZCI6MzMuMDgyMDU2NzMzNTIxODksImRhc2hfc2l6ZSI6MC45MTUyNzAyMzYyOTQxMDU1LCJkYXNoZXMiOmZhbHNlLCJzdWJ0cmFjdGl2ZV9jb2xvciI6ZmFsc2UsImhhaXJTaGluZSI6MTAsImhhaXJTcGVjQ29sb3IiOlsxLDEsMV19LCJDIjp7InBvcyI6Wy03LjQyNjkzNjMzNzgzOTcxLC02Ljk5ODI1Mjk3MjIzMzY1OSwxMTcuMTMyNDU3OTg4NDA0MDddLCJ0YXIiOlsxLjE4NTQzMDE1NTUyNDU3NCwtMS4zMzUzOTk3MDQyNDcyNDA1LDI3Ljk0Nzk3NzA0NDE1MDk1N10sIm5lYXIiOjAuMDM0NjQxMDE2MTUxMzc3NTUsImZhciI6MzQ2NDEuMDE2MTUxMzc3NTQ2fSwiRSI6eyJjb2RlIjoiXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMb3JlbnogYXR0cmFjdG9yXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmNvbnN0IGZsb2F0IGthcHBhID0gZmxvYXQoMS44NCk7XG5jb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KDYuNyk7XG5cbiNkZWZpbmUgcmdiIHZlYzNcblxuY29uc3QgdmVjMyBjb2xMbyA9IHJnYigyNTQsNDUsNzMpIC8gMjU1LjA7XG5jb25zdCB2ZWMzIGNvbEhpID0gcmdiKDUsMTM4LDI1NSkgLyAyNTUuMDtcbmNvbnN0IGZsb2F0IG1hZ1NjYWxlID0gZmxvYXQoMC42KTtcblxuY29uc3QgZmxvYXQgcmhvICAgPSBmbG9hdCgyOC4wKTsgICAgIFxuY29uc3QgZmxvYXQgc2lnbWEgPSBmbG9hdCgxMC4wKTtcbmNvbnN0IGZsb2F0IGJldGEgID0gZmxvYXQoOC4wKS9mbG9hdCgzLjApO1xuXG5cbiB2ZWMzIHZlbG9jaXR5KHZlYzMgcCwgZmxvYXQgdClcbiB7XG4gICAgIHZlYzMgdjtcbiAgICAgZmxvYXQgeCA9IHAueDtcbiAgICAgZmxvYXQgeSA9IHAueTtcbiAgICAgZmxvYXQgeiA9IHAuejtcbiAgICAgdi54ID0gc2lnbWEqKHkgLSB4KTtcbiAgICAgdi55ID0geCoocmhvIC0geik7XG4gICAgIHYueiA9IHgqeSAtIGJldGEqejtcbiAgICAgcmV0dXJuIHY7XG4gfSAgICBcbiBcbiBcbnZlYzMgY29sb3IodmVjMyBwLCBmbG9hdCB0KVxue1xuICAgIHZlYzMgdiA9IHZlbG9jaXR5KHAsIHQpO1xuICBcdGZsb2F0IG1hZzIgPSB0L21hZ1NjYWxlO1xuICAgIGZsb2F0IGxlcnAgPSBtYWcyLygxLjArbWFnMik7XG4gICAgcmV0dXJuICgxLjAtbGVycCkqY29sTG8gKyBsZXJwKmNvbEhpO1xufSAgXG4ifX0%3D)

Visualized with [Fibre](https://github.com/portsmouth/fibre)


Hadley System
--------------------------------------------------------------------------------

  $$
  \begin{array}{lll}
  \dot{x} &=& -y^2 - z^2 - ax + af\\
  \dot{y} &=& xy - b xz - y + g \\
  \dot{z} &=& bxy + xz - z
  \end{array}
  $$

--------------------------------------------------------------------------------

[![](images/static/hadley-attractor.png)](https://portsmouth.github.io/fibre/?settings=eyJSIjp7InJheUJhdGNoIjoxMjgsIm1heFRpbWVTdGVwcyI6MzE5LCJtYXhJdGVyYXRpb25zIjoxMDAsImludGVncmF0aW9uVGltZSI6MjAsImludGVncmF0ZUZvcndhcmQiOnRydWUsImdyaWRTcGFjZSI6MC4wMDUsInR1YmVXaWR0aCI6MC4wMTg3NDc4NDI2MTk1ODA5MzIsInR1YmVTcHJlYWQiOmZhbHNlLCJyZWNvcmRfcmVhbHRpbWUiOnRydWUsInhtaW4iOi0xLjg0MjQzOTkxMzY3MjEzMjEsInhtYXgiOi0xLjY5NzQwMDg2MTM5ODUwMjUsInltaW4iOi0wLjc1MDc5Mzc1MTk1Njc2MDIsInltYXgiOi0wLjI5OTU4ODE4NTU3MDA5MzE1LCJ6bWluIjotMC44MTQyMDU1NzE1Mzg3ODkzLCJ6bWF4IjotMC43NTYwODExMDg1OTM5NzI5LCJjbGlwVG9Cb3VuZHMiOmZhbHNlLCJzaG93Qm91bmRzIjp0cnVlLCJleHBvc3VyZSI6LTEuMTc3NDg1ODI2MDc5NTYxLCJnYW1tYSI6MS4wMjU2MTcyNzI3MTgyNTEsImNvbnRyYXN0IjoxLjI5MDI5MjY5NzkzNTg2NDIsInNhdHVyYXRpb24iOjEuNDU1NzE0ODM4Njk2ODcyMywic3VidHJhY3RpdmVDb2xvciI6ZmFsc2UsImJnQ29sb3IiOlswLDAsMF0sImhhaXJTaGFkZXIiOmZhbHNlLCJzcGVjU2hpbmUiOjMxLjg5NzQ4MDA3NzUzNjA3Nywic3BlY0NvbG9yIjpbMSwxLDFdLCJsaWdodDFfY29sb3IiOlsxLDAuOSwwLjhdLCJsaWdodDJfY29sb3IiOlswLjgsMC45LDFdLCJsaWdodDFfZGlyIjpbMC41NzczNTAyNjkxODk2MjU4LDAuNTc3MzUwMjY5MTg5NjI1OCwwLjU3NzM1MDI2OTE4OTYyNThdLCJsaWdodDJfZGlyIjpbLTAuNTc3MzUwMjY5MTg5NjI1OCwtMC41NzczNTAyNjkxODk2MjU4LC0wLjU3NzM1MDI2OTE4OTYyNThdLCJkZXB0aFRlc3QiOnRydWUsImRhc2hfc3BhY2luZyI6MC41NDAzNDAyNTk5ODA4NTc0LCJkYXNoX3NwZWVkIjozMy4wODIwNTY3MzM1MjE4OSwiZGFzaF9zaXplIjowLjkxNTI3MDIzNjI5NDEwNTUsImRhc2hlcyI6ZmFsc2UsInN1YnRyYWN0aXZlX2NvbG9yIjpmYWxzZSwiaGFpclNoaW5lIjoxMCwiaGFpclNwZWNDb2xvciI6WzEsMSwxXX0sIkMiOnsicG9zIjpbLTQuMjgwNDkyMTM4MTY3OTY3NSwwLjg4NDU1MjA5Nzk1NTE3MSwtMy40OTI3MzM4Njc0MzM3ODFdLCJ0YXIiOlswLjQ0MzkwMDY5MjE1MTE1OTUsMC4xMDk3ODc2ODUzODYxNzI1MywtMC4xNDE1NTE2NDc4Mzk3MTEzXSwibmVhciI6MC4wMzQ2NDEwMTYxNTEzNzc1NSwiZmFyIjozNDY0MS4wMTYxNTEzNzc1NDZ9LCJFIjp7ImNvZGUiOiJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhhZGxleSBhdHRyYWN0b3Jcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY29uc3QgZmxvYXQgYSA9IGZsb2F0KDAuMik7XG5jb25zdCBmbG9hdCBiID0gZmxvYXQoNC4wKTtcbmNvbnN0IGZsb2F0IGYgPSBmbG9hdCg4LjApO1xuY29uc3QgZmxvYXQgZyA9IGZsb2F0KDEuMCk7XG5cbiNkZWZpbmUgcmdiIHZlYzNcblxuY29uc3QgdmVjMyBjb2xMbyA9IHJnYigyNTUsNjEsODcpIC8gMjU1LjA7XG5jb25zdCB2ZWMzIGNvbEhpID0gcmdiKDg2LDE3NiwyNTQpIC8gMjU1LjA7XG5jb25zdCBmbG9hdCBtYWdTY2FsZSA9IGZsb2F0KDYpO1xuXG52ZWMzIHZlbG9jaXR5KHZlYzMgcCwgZmxvYXQgdClcbntcbiAgICB2ZWMzIHY7XG4gICAgZmxvYXQgeCA9IHAueDtcbiAgICBmbG9hdCB5ID0gcC55O1xuICAgIGZsb2F0IHogPSBwLno7XG4gICAgdi54ID0gLXkqeSAteip6IC1hKnggKyBhKmY7XG4gICAgdi55ID0geCp5IC0gYip4KnogLSB5ICsgZztcbiAgICB2LnogPSBiKngqeSArIHgqeiAtIHo7XG4gICAgcmV0dXJuIHY7XG59ICAgIFxuIFxudmVjMyBjb2xvcih2ZWMzIHAsIGZsb2F0IHQpXG57XG4gICAgdmVjMyB2ID0gdmVsb2NpdHkocCwgdCk7XG4gICAgZmxvYXQgbWFnMiA9IHQvbWFnU2NhbGU7XG4gICAgZmxvYXQgbGVycCA9IG1hZzIvKDEuMCttYWcyKTtcbiAgICByZXR1cm4gKDEuMC1sZXJwKSpjb2xMbyArIGxlcnAqY29sSGk7XG59ICBcbiJ9fQ%3D%3D)

Visualized with [Fibre](https://github.com/portsmouth/fibre)



Equilibrium
--------------------------------------------------------------------------------

An **equilibrium** of system $\dot{x} = f(x)$ is a state $x_e$
such that the maximal solution of this system such that $x(0) = x_e$ 
is $x(t) = x_e$ for any $t > 0$.

The state $x_e$ is an equilibrium if and only if $f(x_e) = 0$.


--------------------------------------------------------------------------------

### <i class="fa fa-question-circle-o"></i> -- Equilibrium / Pendulum

**Reminder:** the pendulum is governed by the equation

  $$
  m \ell^2 \ddot{\theta} + b \dot{\theta} + m g \ell \sin \theta = 0
  $$

  - [<i class="fa fa-superscript"></i>] 
    Find the equilibriums of this dynamics.




Stability
--------------------------------------------------------------------------------

About the long-term behavior of solutions.

  - "Stability" subtle concept,

  - "Asymptotic Stability" simpler (and stronger),

  - "Attractivity" simpler yet, (but often too weak).


Attractivity
--------------------------------------------------------------------------------

Consider a well-posed ODE $\dot{x} = f(x)$.

An equilibrium $x_e$ is: 

  - **globally attractive** if for every $x_0$,
    the maximal solution $x(t)$ of the IVP with $x(0)=x_0$ 
    exists for any $t\geq 0$ and
      $$
      \lim_{t \to +\infty} x(t) = x_e.
      $$

  - **locally attractive** if this property holds when $x_0$ 
    is sufficiently close to the equilibrium $x_e$.

--------------------------------------------------------------------------------

    def f(xy):
        x, y = xy
        dx = -2*x + y
        dy = -2*y + x
        return [dx, dy]
    figure()
    x = y = linspace(-5.0, 5.0, 1000)
    streamplot(*Q(f, x, y), color="k") 
    plot([0], [0], "k.", ms=10.0)
        

Globally Attractive
--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    axis("square")
    tight_layout()
    save("images/globally-attractive")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

![](images/globally-attractive.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

--------------------------------------------------------------------------------

    def f(xy):
        x, y = xy
        dx = -2*x + y**3
        dy = -2*y + x**3
        return [dx, dy]
    figure()
    x = y = linspace(-5.0, 5.0, 1000)
    streamplot(*Q(f, x, y), color="k") 
    plot([0], [0], "k.", ms=10.0)
        

Locally Attractive
--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    axis("square")
    tight_layout()
    save("images/locally-attractive")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

![](images/locally-attractive.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        

--------------------------------------------------------------------------------

### <i class="fa fa-question-circle-o"></i> -- Equilibrium / Stability

Consider a pendulum with a coefficient of friction $b$.

  - [<i class="fa fa-gears"></i>] 
    Is any equilibrium globally attractive?

  - [<i class="fa fa-flask"></i>, <i class="fa fa-area-chart"></i>] 
    
    - Assume that $b>0$.
      Determine graphically the equilibriums which are locally attractive.

    - What happens when $b=0$?

--------------------------------------------------------------------------------

  - [<i class="fa fa-gears"></i>, <i class="fa fa-superscript"></i>] 
    Prove that no equilibrium is locally attractive when $k=0$.  
    <i class="fa fa-key"></i> **Hint:** study the evolution in time
      $$
      E = J \dot{\theta}^2 / 2 - m g\ell \cos \theta,
      $$
    with $J = m\ell^2$, the total mechanical energy of the pendulum.


Attractivity
--------------------------------------------------------------------------------

The equilibrium $x_e$ is globally attractive iff:

  - for any $x_0$ and for any $\epsilon > 0$, 
    there is a $\tau \geq 0$ such that the maximal solution $x(t)$ 
    such that $x(0) = x_0$ exists for all $t \geq 0$ and 
    satisfies:

    $$
    \|x(t) - x_e\| \leq \epsilon \; \mbox{ when } \; t \geq \tau.
    $$

<i class="fa fa-warning"></i>
--------------------------------------------------------------------------------

  - Very close values of $x(0)$ could lead to very different 
    "speed of convergence" towards the equilibrium.

  - This is not contradictory with the well-posedness assumption:
    continuity w.r.t. the initial condition only works with finite time spans.


Example
--------------------------------------------------------------------------------

  $$
  \left|
  \begin{array}{lll}
  \dot{x} &=& x + xy - (x + y)\sqrt{x^2 + y^2} \\
  \dot{y} &=& y - x^2 + (x - y) \sqrt{x^2 + y^2}
  \end{array}
  \right.
  $$

--------------------------------------------------------------------------------

Equivalently, in polar coordinates:

  $$
  \left|
  \begin{array}{lll}
  \dot{r} &=& r (1 - r) \\
  \dot{\theta} &=& r (1 - \cos \theta)
  \end{array}
  \right.
  $$

Stream Plot
--------------------------------------------------------------------------------

    def f(xy):
        x, y = xy
        r = sqrt(x*x + y*y)
        dx = x + x * y - (x + y) * r
        dy = y - x * x + (x - y) * r
        return [dx, dy]

--------------------------------------------------------------------------------

    figure()
    x = y = linspace(-2.0, 2.0, 1000)
    streamplot(*Q(f, x, y), color="k") 
    plot([1], [0], "k.", ms=10.0)

--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    axis("square")
    tight_layout()
    save("images/attractive2")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

![](images/attractive2.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

--------------------------------------------------------------------------------

Make sure that the rhs is time-dependent:

    def fun(t, y):
        return f(y)

Pick a large time span and an initial state 
just above the equilibrium $(1.0, 0.0)$:

    t_span = (0.0, 500.0)
    theta_0 = 2 * pi / 1000
    y0 = [cos(theta_0), sin(theta_0)]

--------------------------------------------------------------------------------

    y = solve_ivp(fun, t_span, y0=y0, dense_output=True).sol
    t = linspace(t_span[0], t_span[-1], 1000)
    figure()
    x1, x2 = y(t)[0], y(t)[1]
    plot(t, x1, "C0")
    plot(t, x2, "C1")
    grid()
    xlabel("$t$")

--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    #axis("square")
    tight_layout()
    save("images/attractive-time")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

![](images/attractive-time.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


--------------------------------------------------------------------------------        

### Example -- Vinograd

    def f(xy):
        x, y = xy
        q = x**2 + y**2 * (1 + (x**2 + y**2)**2) 
        dx = (x**2 * (y - x) + y**5) / q
        dy = y**2 * (y - 2*x) / q
        return [dx, dy]


--------------------------------------------------------------------------------

    figure()
    x = y = linspace(-1.0, 1.0, 1000)
    streamplot(*Q(f, x, y), color="k") 
    xticks([-1, 0, 1])
    plot([0], [0], "k.", ms=10.0)

--------------------------------------------------------------------------------

::: hidden :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

    axis("square")
    tight_layout()
    save("images/vinograd")

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

::: slides :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

![](images/vinograd.svg)    

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

**TODO:** exo with Vinograd?
--------------------------------------------------------------------------------

### <i class="fa fa-question-circle-o"></i> -- Existence / Sigmoid

Asymptotic Stability
--------------------------------------------------------------------------------

Asymptotic stability is a stronger version of attractivity 
which is by definition robust with respect to the choice of
the initial state.

--------------------------------------------------------------------------------

The equilibrium $x_e$ is **globally asymptotically stable** if:

  - for any $x_0$ and for any $\epsilon > 0$, 
    there is a $\tau \geq 0$ **and a $r > 0$
    such that if $\|x_1 - x_0\| \leq r$**, 
    the maximal solution $x(t)$ 
    **such that $x(0) = x_1$** exists for all $t \geq 0$ and 
    satisfies:

    $$
    \|x(t) - x_e\| \leq \epsilon \; \mbox{ when } \; t \geq \tau.
    $$

--------------------------------------------------------------------------------

Equivalently (perhaps simpler): 

  - **for any bounded set $B$**, for any $\epsilon > 0$, 
    there is a $\tau \geq 0$ such that any maximal solution $x(t)$ 
    **such that $x(0) \in B$** exists for all $t \geq 0$ and 
    satisfies:

    $$
    \|x(t) - x_e\| \leq \epsilon \; \mbox{ when } \; t \geq \tau.
    $$


--------------------------------------------------------------------------------

**TODO:** Systems with inputs and outputs.






<style>

.reveal section img {
  border:0;
  height:50vh;
  width:auto;

}

.reveal section img.medium {
  border:0;
  max-width:50vh;
}

.reveal section img.icon {
  display:inline;
  border:0;
  width:1em;
  margin:0em;
  box-shadow:none;
  vertical-align:-10%;
}

.reveal code {
  font-family: Inconsolata, monospace;
}

.reveal pre code {
  font-size: 1.5em;
  line-height: 1.5em;
  /* max-height: 80wh; won't work, overriden */
}

input {
  font-family: "Source Sans Pro", Helvetica, sans-serif;
  font-size: 42px;
  line-height: 54.6px;
}

</style>

<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet"> 

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet">
